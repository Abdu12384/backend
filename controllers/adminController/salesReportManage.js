
const PDFDocument = require('pdfkit');
const Order = require('../../model/orderModel');
const exceljs = require('exceljs');



const generatePDFReport = async (req, res) => {
  try {
    const { timeFilter, sortBy = 'orderDate', sortOrder = -1 } = req.query;
    

    const dateFilter = {};
    const now = new Date();
    let startDate = new Date();
    let dateRangeText = 'All Time';
    
    if (timeFilter !== 'All Time') {
      switch (timeFilter) {
        case 'Daily':
          startDate.setHours(0, 0, 0, 0);
          dateRangeText = startDate.toLocaleDateString();
          break;
        case 'Weekly':
          startDate.setDate(now.getDate() - now.getDay());
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
        case 'Monthly':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
      }
      dateFilter.orderDate = { $gte: startDate };
    }


    const orders = await Order.find(dateFilter)
      .sort({ [sortBy]: parseInt(sortOrder) })
      .populate('userId')
      .populate('products.productId');


    const summary = {
      totalOrders: orders.length,
      totalRevenue: orders.reduce((sum, order) => sum + order.totalPrice, 0),
      totalDiscount: orders.reduce((sum, order) => sum + (order.discount || 0), 0),
      averageOrderValue: orders.length > 0 ? 
        orders.reduce((sum, order) => sum + order.totalPrice, 0) / orders.length : 0
    };


    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
      bufferPages: true 
    });

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'attachment; filename=sales-report.pdf');
    doc.pipe(res);

    // Helper function for consistent styling
    const styles = {
      title: { font: 'Helvetica-Bold', size: 25 },
      subtitle: { font: 'Helvetica', size: 12 },
      heading: { font: 'Helvetica-Bold', size: 14 },
      tableHeader: { font: 'Helvetica-Bold', size: 10 },
      tableCell: { font: 'Helvetica', size: 10 },
      footer: { font: 'Helvetica', size: 8 }
    };

    const setStyle = (style) => {
      doc.font(style.font).fontSize(style.size);
    };


    const addHeader = () => {


      // Add decorative line
      doc.lineWidth(2)
         .moveTo(50, 40)
         .lineTo(545, 40)
         .stroke('#2196F3');

      setStyle(styles.title);
      doc.text('Sales Report', 50, 60);
      
      setStyle(styles.subtitle);
      doc.text(`Generated on: ${new Date().toLocaleString()}`, 50, 90);
      doc.text(`Date Range: ${dateRangeText}`, 50, 110);

      // Add another decorative line
      doc.lineWidth(1)
         .moveTo(50, 130)
         .lineTo(545, 130)
         .stroke('#E0E0E0');
    };

    // Add footer with page numbers
    const addFooter = () => {
      const pages = doc.bufferedPageRange();
      for (let i = 0; i < pages.count; i++) {
        doc.switchToPage(i);
        setStyle(styles.footer);
        
        // Add footer text
        doc.text(
          'Generated by Your Company Name',
          50,
          doc.page.height - 50,
          { align: 'left' }
        );
        
        // Add page number
        doc.text(
          `Page ${i + 1} of ${pages.count}`,
          doc.page.width - 150,
          doc.page.height - 50,
          { align: 'right' }
        );
      }
    };

    // Start adding content
    addHeader();

    // Add summary section with styled boxes
    setStyle(styles.heading);
    doc.text('Summary', 50, 150);

    // Create summary boxes
    const boxWidth = 120;
    const boxHeight = 60;
    const boxSpacing = 15;
    const boxes = [
      { label: 'Total Orders', value: summary.totalOrders.toString() },
      { label: 'Total Revenue', value: `₹${summary.totalRevenue.toFixed(2)}` },
      { label: 'Total Discount', value: `₹${summary.totalDiscount.toFixed(2)}` },
      { label: 'Avg. Order Value', value: `₹${summary.averageOrderValue.toFixed(2)}` }
    ];

    boxes.forEach((box, index) => {
      const x = 50 + (index * (boxWidth + boxSpacing));
      const y = 170;


      doc.rect(x, y, boxWidth, boxHeight)
         .fill('#F5F5F5');


      setStyle(styles.tableHeader);
      doc.fill('#666666')
         .text(box.label, x + 10, y + 15, { width: boxWidth - 20, align: 'center' });


      setStyle(styles.tableCell);
      doc.fill('#000000')
         .text(box.value, x + 10, y + 35, { width: boxWidth - 20, align: 'center' });
    });


    doc.addPage();
    addHeader(); 

    setStyle(styles.heading);
    doc.text('Order Details', 50, 150);

    const orderTable = {
      headers: ['Order ID', 'Product', 'Quantity', 'Date', 'Customer','Discount', 'Total'],
      rows: orders.map(order => [
        order._id.toString().slice(-6),
        order.products[0]?.productId?.productName || '',
        order.products[0]?.quantity.toString() || '',
        new Date(order.orderDate).toLocaleDateString(),
        order.userId?.fullName || '',
        `₹${(order.discount || 0).toLocaleString()}`,
        `₹${order.totalPrice.toLocaleString()}`
      ])
    };

    // Enhanced table creation with alternating row colors
    const createTable = (doc, table, startY) => {
      const columnCount = table.headers.length;
      const columnWidth = (doc.page.width - 100) / columnCount;
      let yPos = startY;

      // Draw headers with background
      doc.rect(50, yPos, doc.page.width - 100, 20)
         .fill('#2196F3');

      setStyle(styles.tableHeader);
      doc.fill('#FFFFFF');
      table.headers.forEach((header, i) => {
        doc.text(header, 50 + (i * columnWidth), yPos + 5, {
          width: columnWidth,
          align: 'left'
        });
      });


      setStyle(styles.tableCell);
      table.rows.forEach((row, rowIndex) => {
        yPos += 25;


        if (yPos > doc.page.height - 75) {
          doc.addPage();
          addHeader();
          yPos = 150;


          doc.rect(50, yPos, doc.page.width - 100, 20)
             .fill('#2196F3');

          setStyle(styles.tableHeader);
          doc.fill('#FFFFFF');
          table.headers.forEach((header, i) => {
            doc.text(header, 50 + (i * columnWidth), yPos + 5, {
              width: columnWidth,
              align: 'left'
            });
          });
          yPos += 25;
          setStyle(styles.tableCell);
        }

        // Draw alternating row background
        if (rowIndex % 2 === 0) {
          doc.rect(50, yPos - 5, doc.page.width - 100, 20)
             .fill('#F5F5F5');
        }

        doc.fill('#000000');
        row.forEach((cell, i) => {
          doc.text(cell, 50 + (i * columnWidth), yPos, {
            width: columnWidth,
            align: 'left'
          });
        });
      });

      return yPos;
    };

    createTable(doc, orderTable, 180);

    // Add footer to all pages
    addFooter();

    // Finalize the PDF
    doc.end();
  } catch (error) {
    console.error('PDF generation error:', error);
    res.status(500).json({ error: 'Failed to generate PDF report' });
  }
};







const salesData =  async (req, res) => {
    try {

      
        const { 
            timeFilter, 
            sortBy = 'orderDate', 
            sortOrder = -1,
            page = 1,
            limit = 10
        } = req.query;

        const dateFilter = {};
        const now = new Date();

        if (timeFilter !== 'All Time') {
            let startDate = new Date();
            switch (timeFilter) {
                case 'Daily':
                    startDate.setHours(0, 0, 0, 0);
                    break;
                case 'Weekly':
                    startDate.setDate(now.getDate() - now.getDay());
                    break;
                case 'Monthly':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
            }
            dateFilter.orderDate = { $gte: startDate };
        }

        const sortConfig = {};
        sortConfig[sortBy] = parseInt(sortOrder);

        const skip = (page - 1) * limit;

        const orders = await Order.find(dateFilter)
            .sort(sortConfig)
            .skip(skip)
            .limit(parseInt(limit))
            .populate('userId')
            .populate('products.productId');

         const summury = await Order.find()   
            const OrderSummury = {
              totalOrders: summury.length,
              totalRevenue: summury.reduce((sum, order) => sum + order.totalPrice, 0),
              totalDiscount: summury.reduce((sum, order) => sum + (order.discount || 0), 0),
              timeRange: timeFilter,
              sortedBy: sortBy,
              sortOrder: sortOrder === 1 ? 'ascending' : 'descending'
          };
        const total = await Order.countDocuments(dateFilter);




    

        res.json({
            orders,
            pagination: {
                total,
                pages: Math.ceil(total / limit),
                currentPage: parseInt(page),
                limit: parseInt(limit)
            },
            OrderSummury 
        });

    } catch (error) {
        console.error('Error fetching sales data:', error);
        res.status(500).json({ error: 'Failed to fetch sales data' });
    }
}












const generateExcelReport = async (req, res) => {
  try {
    const { timeFilter, sortBy = 'orderDate', sortOrder = -1 } = req.query;
    
    const dateFilter = {};
    const now = new Date();
    let startDate = new Date();
    let dateRangeText = 'All Time';
    
    if (timeFilter !== 'All Time') {
      switch (timeFilter) {
        case 'Daily':
          startDate.setHours(0, 0, 0, 0);
          dateRangeText = startDate.toLocaleDateString();
          break;
        case 'Weekly':
          startDate.setDate(now.getDate() - now.getDay());
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
        case 'Monthly':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
      }
      dateFilter.orderDate = { $gte: startDate };
    }

    const orders = await Order.find(dateFilter)
      .sort({ [sortBy]: parseInt(sortOrder) })
      .populate('userId')
      .populate('products.productId');


    const summary = {
      totalOrders: orders.length,
      totalRevenue: orders.reduce((sum, order) => sum + order.totalPrice, 0),
      totalDiscount: orders.reduce((sum, order) => sum + (order.discount || 0), 0),
      averageOrderValue: orders.length > 0 ? 
        orders.reduce((sum, order) => sum + order.totalPrice, 0) / orders.length : 0
    };

    const workbook = new exceljs.Workbook();
    workbook.creator = 'Your Company Name';
    workbook.created = new Date();


    const mainSheet = workbook.addWorksheet('Sales Report');
    

    mainSheet.columns = [
      { width: 15 }, { width: 30 }, { width: 15 }, 
      { width: 20 }, { width: 20 }, { width: 15 }
    ];


    mainSheet.mergeCells('A1:F1');
    const titleRow = mainSheet.getRow(1);
    titleRow.getCell(1).value = 'Sales Report';
    titleRow.getCell(1).font = { 
      name: 'Arial',
      size: 20,
      bold: true,
      color: { argb: 'FF2196F3' }
    };
    titleRow.height = 30;


    mainSheet.addRow([]);
    for (let col = 1; col <= 6; col++) {
      const cell = mainSheet.getRow(2).getCell(col);
      cell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF2196F3' }
      };
    }
    mainSheet.getRow(2).height = 2;


    mainSheet.addRow([`Generated on: ${new Date().toLocaleString()}`]);
    mainSheet.addRow([`Date Range: ${dateRangeText}`]);
    mainSheet.addRow([]);


    const summaryRow = mainSheet.addRow(['Summary']);
    summaryRow.font = { bold: true, size: 12 };
    mainSheet.addRow([]);


    const summaryData = [
      ['Total Orders', summary.totalOrders],
      ['Total Revenue', `₹${summary.totalRevenue.toFixed(2)}`],
      ['Total Discount', `₹${summary.totalDiscount.toFixed(2)}`],
      ['Avg. Order Value', `₹${summary.averageOrderValue.toFixed(2)}`]
    ];

    // Add summary boxes with styling
    summaryData.forEach((data, index) => {
      const row = mainSheet.addRow([data[0], data[1]]);
      const cells = [row.getCell(1), row.getCell(2)];
      
      cells.forEach(cell => {
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFF5F5F5' }
        };
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
      
      cells[0].font = { bold: true, size: 10, color: { argb: 'FF666666' } };
      cells[1].font = { size: 10 };
    });

    mainSheet.addRow([]);
    mainSheet.addRow([]);

    // Add Order Details section
    const orderHeaderRow = mainSheet.addRow(['Order Details']);
    orderHeaderRow.font = { bold: true, size: 12 };
    mainSheet.addRow([]);

    // Add order details table
    const headers = ['Order ID', 'Product', 'Quantity', 'Date', 'Customer', 'Total','Discount'];
    const headerRow = mainSheet.addRow(headers);
    
    // Style header row
    headerRow.eachCell((cell) => {
      cell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF2196F3' }
      };
      cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });


    orders.forEach((order, index) => {
      const row = mainSheet.addRow([
        order._id.toString().slice(-6),
        order.products[0]?.productId?.productName || '',
        order.products[0]?.quantity.toString() || '',
        new Date(order.orderDate).toLocaleDateString(),
        order.userId?.fullName || '',
        `₹${order.totalPrice.toLocaleString()}`,
        `₹${(order.discount || 0).toLocaleString()}`
      ]);

      // Add alternating row colors
      row.eachCell((cell) => {
        if (index % 2 === 0) {
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFF5F5F5' }
          };
        }
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
    });

    // Add footer
    mainSheet.addRow([]);
    const footerRow = mainSheet.addRow(['Generated by Your Company Name']);
    footerRow.getCell(1).font = { size: 8, color: { argb: 'FF666666' } };

    // Set response headers
    res.setHeader(
      'Content-Type', 
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );
    res.setHeader(
      'Content-Disposition', 
      `attachment; filename=sales-report-${dateRangeText.replace(/\s/g, '-')}.xlsx`
    );


    await workbook.xlsx.write(res);
    res.end();
  } catch (error) {
    console.error('Excel generation error:', error);
    res.status(500).json({ error: 'Failed to generate Excel report' });
  }
};






module.exports={
  generatePDFReport,
  generateExcelReport,
  salesData
}